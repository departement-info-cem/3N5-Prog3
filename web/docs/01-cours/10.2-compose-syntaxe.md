---
title: Compose syntaxe
description: Compose syntaxe
hide_table_of_contents: true
---

# Compose syntaxe, les subtilités

## Facile : fonctions en majuscule = contravention aux conventions Kotlin

Les fonctions Composable commencent par une majuscule, contrairement aux conventions de nommage en Kotlin où les fonctions commencent par une minuscule. 
- Convention juste pour compose
- Pourrait nous mélanger avec des appels de constructeur
- Row() est un appel de compose
- Random() est un appel de constructeur

**Ce sont bien des fonctions** en compose.

## Intermédiaire : Syntaxe des appels de fonctions Compose : () et {}

En Jetpack Compose, l'appel d'une fonction Compose utilise la syntaxe habituelle des parenthèses (). Cependant, lorsqu'une fonction prend un paramètre de type lambda (fonction anonyme), il est possible d'utiliser la syntaxe dite "trailing lambda" : le bloc de code lambda est placé après les parenthèses, entre accolades {}. Cette fonctionnalité provient du langage Kotlin.
- Dans un appel fonction classique, on a des () : **maFonction(5, 6)**
- En kotlin, si le dernier paramètre est une lambda, on peut la déporter après les parenthèses
- On appelle ça une trailing lambda

### Exemple

Voici deux façons équivalentes d'utiliser un composant Row :

<Row>
<Column>
    
    ```kotlin
    // Utilisation du trailing lambda
    Row {
        Column { /* contenu */ }
        Column { /* contenu */ }
    }
    ```
</Column>
<Column>
    ```kotlin
    // Lambda passé dans les parenthèses
    Row(content = {
        Column { /* contenu */ }
        Column { /* contenu */ }
    })
    ```
</Column>
</Row>

- Le contenu de la Row est défini par une lambda
- La syntaxe diffère selon la position du bloc {}
- Juste la dernière lambda peut être déportée

### Code source de Column

```kotlin
@Composable
inline fun Column(
    modifier: Modifier = Modifier,
    verticalArrangement: Arrangement.Vertical = Arrangement.Top,
    horizontalAlignment: Alignment.Horizontal = Alignment.Start,
    content: @Composable ColumnScope.() -> Unit
) {
    val measurePolicy = columnMeasurePolicy(verticalArrangement, horizontalAlignment)
    Layout(
        content = { ColumnScopeInstance.content() },
        measurePolicy = measurePolicy,
        modifier = modifier
    )
}
```

## Difficile : le Modifier

- `modifier` permet de chaîner plusieurs transformations ou décorations sur un composant. 
- Chaque appel à une fonction comme `padding`, `background`, `fillMaxWidth`, etc., retourne un nouvel objet `Modifier`
- Ça permet de les enchaîner facilement.

Ce mécanisme repose sur le patron de conception **Chain of Responsibility** (chaîne de responsabilité), où chaque transformation modifie ou enrichit le comportement du composant.

### Exemple d'utilisation de Modifier

```kotlin
Row(
    modifier = Modifier
        .padding(8.dp)
        .background(Color.LightGray)
        .fillMaxWidth()
) {
    // contenu
}
```

Dans cet exemple, le `Row` aura un padding de 8dp, un fond gris clair et prendra toute la largeur disponible. Chaque appel retourne un nouveau `Modifier` enrichi, permettant de composer facilement plusieurs effets.

## God mode : gestion de l'état avec remember

En Jetpack Compose, la fonction `remember` permet de conserver une valeur en mémoire à travers les recompositions d'une fonction composable. Cela signifie que la valeur stockée avec `remember` ne sera pas réinitialisée à chaque fois que la fonction est réévaluée, sauf si les clés de dépendance changent ou si le composant est retiré de la composition.

`remember` est souvent utilisé pour stocker l'état local d'un composant, comme une variable qui doit survivre aux changements d'interface mais rester propre à la composable.

### Exemple d'utilisation de remember

```kotlin
@Composable
fun Compteur() {
    var count by remember { mutableStateOf(0) }
    Button(onClick = { count++ }) {
        Text("Compteur : $count")
    }
}
```

Dans cet exemple, la variable `count` est conservée grâce à `remember`. À chaque clic, la valeur est incrémentée et l'interface se met à jour, mais la valeur n'est pas perdue lors des recompositions.

Références : 
- https://medium.com/kotlin-android-chronicle/what-happens-internally-in-remember-in-jetpack-compose-c63aa38f47dd


EN CONSTRUCTION